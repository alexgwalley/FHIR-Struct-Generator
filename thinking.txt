mass FHIR visualization / exploration / data analysis
fun performance project
Want to rethink how FHIR could be organized in memory for greater filtering and being nice to cache lines.


When searching through fhir, it is basically just a collection of codes and dates with various meta data to explain their use

What do people want to look at when doing population data? (Thinking of cert team)
- Look at all coverages, time periods to look for gaps or repetition.
- Look at all encounters throughout the year, time frames, codes / valuesets used and _not_ used
- MedicationDispense, Vaccine, Procedure,  

Take all of the Period, DateTime, Date
struct Times {
	 u64 startTimes[];
	 u64 endTimes[];
 }

struct Resources {
	Times encounters;
	Times procedures;
	Times conditionOnsets;
 }

24 meta flags?

enum Flags {
	Allergy = (1 << 0)
	CarePlan = (1 << 0)
	Condition = (1 << 0)
	Coverage = (1 << 0)
	Death = (1 << 0)
	Device = (1 << 0)
	DiagnosticReport = (1 << 0)
	Encounter = (1 << 0)
	ImagingStudy = (1 << 0)
	Immunization = (1 << 0)
	Observation = (1 << 0)
	Procedure = (1 << 0)
	SupplyList = (1 << 0)
	Symptom = (1 << 0)
	Vaccine = (1 << 0)
	VitalSign = (1 << 0)
	Claim = (1 << 0)
	ExplanationOfBenefits = (1 << 0)

	Encounter = (1 << 0)
	Encounter = (1 << 0)
	Encounter = (1 << 0)
	Encounter = (1 << 0)
	Encounter = (1 << 0)
	Encounter = (1 << 0)
}

typedef u32 CodeHash;
Dictionary<CodeHash, string> codehash_to_code;

sizeof(Code) = 8 bytes, so 8 Code's per cache line
struct Code {
	u32 codeHash; //4,294,967,296 4 trillion
	u8 system; // 256 systems

	// 24 bytes left
	Flags flags;
}

 struct Codes {
	u64 codeHashes;
	u64 systemHashes;
 }

==================================
How would I write synthea generation given the constraints of states purely for performance gains?

Bottom-Up design: look for similarities between states (there are many). Basically you are just creating a type of resource and putting some codes in there and recording the time...
Remove a lot of guards...no need, just use conditional transitions. This only works because of the new way time is utilized. In the original synthea,
the modules are re-run and re-run with each module affecting each other module. For the majority case in testing, this is not necessary and slows down the performance.


Types of states: starts resource, ends resource, modifies time, modifies attributes.

typedef u8 StateFlags;
enum StateFlags {
	StartResource,
	EndResource,
	Transition,
	StartAttribute,
	ModifyAttribute,
}

enum ResourceType {
	Allergy: {
		Type: preset list -> CodeableConcept
		Category: preset list -> code
	}.
	CarePlan: {

	},
	Claim,
	Condition: {
		Just Codes!
	},
	Coverage: {
		Codes,
		MMDF info (could be moved separately?)
	},
	Death,
	Device: {
		Manufacturer: string, -> manufacturer
		Model: string -> modelNumber
	},
	DiagnosticReport: {
		Observation: special struct
	},
	Encounter: {
		Class: preset list
		Telemedicine Possibility: preset list
	},
	ImagingStudy: {
		Procedure Code: code,
		Series: {
			Body Site: code,
			Modality: code,
			Instances: code
		}[]
	},
	Medication Order: {
		Booleans,
		Prescription Structure: {
			Refills amount,
			boolean coupled to amount,
			Amount
		}
	}
	Observation: {
		category: preset list
		value:  range | exact | vital sign | value code
	}
	Procedure: {
		reason: StateID,
		duration: Period
	},
	SupplyList: {
		Quantity w/ code
	}
	Symptom: ????
	Vaccine: {
		series: int
	}
	VitalSign: {
		2 string
		quantity: range | exact | exponential | gaussian
	}
};

enum ValueType {
	Unknown,
	String,
	Integer,
	StateReference,
	UnresolvedCode,
	Period,
	Count
};

Value {
	void *value;
	ValueType type;
}

typedef string FhirPath;
ValueAndPath {
	Value value;
	FhirPath path;
};

struct State {
	StateFlags flags;

	AttributeExpression attribute;
	ResourceType resource_type;
	Transition transition;

	ValueAndPath values[];
};

State AllergyState(UnresolvedCode unresolved_codes[], Transition transition, char *type, char *category){
	ValueAndPath values[3];
	values[0] = CreateValue(type, ValueType::String, "AllergyIntolerance.type");
	values[1] = CreateValue(category, ValueType::String, "AllergyIntolerance.category");
	values[2] = CreateValue(ResolveCode(unresolved_codes), ValueType::ResolvedCode, "AllergyIntolerance.code");

	return {
		.flags = StartResource | Transition,
		.resource_type = ResourceType::Allergy,
		.transition = transition,
		.values = values;
	}
}

void ComputeState(Context *context, State *state) {
	if(state.flags & StateFlags::StartResource) {
		
	}

	if(state.flags & StateFlags::EndResource) {
		
	}
		
	if(state.flags & StateFlags::Transition) {
		
	}
}


Attribute Capabilities: Add | Subtract | Equate;

Attribute Types:

Attribute Atomic Value: 
attr_atomic_value_to_ops = {
Int: Add | Sub | Equate
Bool: Equate
Date: Equate | Subtract
}


Operation = Add | Sub | Set | Equate

struct AttributeExpression {
	AttributeName attribute_to_set;
	Operation op;
	AttributeValue value1;
	AttributeValue value2;
}

struct AttributeValue {
	AttributeValueType type;	
	union {
		bool b;
		int i;
		date d;
	} value;
}

attr_to_ops = {
Int : Add | Sub | Equate
Duration: Subtract | Equate 
Boolean: Equate
Date: Equate
}


void ComputeExpression(Context context, AttributeExpression expr) {
	if(expr.value1 != expr.value2) throw Error();
	// Need to add reference
		
	AttrType setType = expr.value1.type;
	if(op not in attr_value_to_ops[setType]) return;

	DoOp(expr.value1, expr.value2);
}


struct DirectTransition {
	StateID destination;
}

struct Transition {
	TransitionType type;
	Flags flags;
	union {
		DirectTransition direct_transition;
		DistributedTransition distributed_transition;
		ConditionalTransition conditional_transition;
	}
};

